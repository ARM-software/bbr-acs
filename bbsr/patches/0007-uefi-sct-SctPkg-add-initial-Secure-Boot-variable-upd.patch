From 2b6c2bf22d20f655cdac4c10ebc005ea1c23197a Mon Sep 17 00:00:00 2001
From: Stuart Yoder <stuart.yoder@arm.com>
Date: Mon, 14 Jun 2021 11:55:55 -0500
Subject: [PATCH 07/22] uefi-sct/SctPkg: add initial Secure Boot variable
 update test

-add initial test to verify the update of KEK with secure boot
 enabled

-generate needed keys and signature lists

-do variable cleanup after test completes

-test assertions covered
  -verify that unsigned update to KEK results in security violation
  -verify that KEK update (KEKSigList1) signed by PK succeeds

Signed-off-by: Stuart Yoder <stuart.yoder@arm.com>
---
 uefi-sct/SctPkg/CommonGenFramework.sh         |  35 +-
 .../BlackBoxTest/Dependency/Keys/GNUmakefile  |  53 +-
 .../SecureBoot/BlackBoxTest/Guid.c            |   2 +
 .../SecureBoot/BlackBoxTest/Guid.h            |   5 +
 .../BlackBoxTest/SecureBootBBTest.inf         |   1 +
 .../BlackBoxTest/SecureBootBBTestMain.c       |   9 +
 .../BlackBoxTest/SecureBootBBTestMain.h       |  10 +
 .../BlackBoxTest/VariableUpdatesBBTest.c      | 728 ++++++++++++++++++
 8 files changed, 834 insertions(+), 9 deletions(-)
 create mode 100644 uefi-sct/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SecureBoot/BlackBoxTest/VariableUpdatesBBTest.c

diff --git a/uefi-sct/SctPkg/CommonGenFramework.sh b/uefi-sct/SctPkg/CommonGenFramework.sh
index ca596fa4..c4909c61 100755
--- a/uefi-sct/SctPkg/CommonGenFramework.sh
+++ b/uefi-sct/SctPkg/CommonGenFramework.sh
@@ -94,6 +94,7 @@ CopyDependency()
     ls -h $ProcessorType/$1_*.ini   >> temp.txt 2>NUL
     ls -h $ProcessorType/$1_*.cmp   >> temp.txt 2>NUL
     ls -h $ProcessorType/$1_*.ucmp  >> temp.txt 2>NUL
+    ls -h $ProcessorType/$1_*.bin  >> temp.txt 2>NUL
     ls -h $ProcessorType/$1_*.der  >> temp.txt 2>NUL
     ls -h $ProcessorType/$1_*.auth  >> temp.txt 2>NUL
 
@@ -106,26 +107,45 @@ CopyDependency()
 
 # *********************************************
 # sign .efi executables for Secure Boot
+#
+# if the KEYS_DIR env variable is set then we
+# use keys supplied by the user, otherwise use
+# keys generated by the SecureBoot SCT test
 # *********************************************
-
 SecureBootSign()
 {
+if [ -n $KEYS_DIR ]
+then
+        TEST_DB1_KEY=$KEYS_DIR/TestDB1.key
+        TEST_DB1_CRT=$KEYS_DIR/TestDB1.crt
+else
+        TEST_DB1_KEY=$ProcessorType/SecureBoot_TestDB1.key
+        TEST_DB1_CRT=$ProcessorType/SecureBoot_TestDB1.crt
+fi
+
 for f in $1/*.efi
 do
-        echo "sbsign --key $ProcessorType/SecureBoot_TestDB1.key --cert $ProcessorType/SecureBoot_TestDB1.crt $f --output $f"
-        sbsign --key $ProcessorType/SecureBoot_TestDB1.key --cert $ProcessorType/SecureBoot_TestDB1.crt $f --output $f
+        echo "sbsign --key $TEST_DB1_KEY --cert $TEST_DB1_CRT $f --output $f"
+        sbsign --key $TEST_DB1_KEY --cert $TEST_DB1_CRT $f --output $f
 done
-
 }
 
 SecureBootSignDependency()
 {
+if [ -n $KEYS_DIR ]
+then
+        TEST_DB1_KEY=$KEYS_DIR/TestDB1.key
+        TEST_DB1_CRT=$KEYS_DIR/TestDB1.crt
+else
+        TEST_DB1_KEY=$ProcessorType/SecureBoot_TestDB1.key
+        TEST_DB1_CRT=$ProcessorType/SecureBoot_TestDB1.crt
+fi
+
 for f in $Framework/Dependency/$1BBTest/*.efi
 do
-        echo "sbsign --key $ProcessorType/SecureBoot_TestDB1.key --cert $ProcessorType/SecureBoot_TestDB1.crt $f --output $f"
-        sbsign --key $ProcessorType/SecureBoot_TestDB1.key --cert $ProcessorType/SecureBoot_TestDB1.crt $f --output $f
+        echo "sbsign --key $TEST_DB1_KEY --cert $TEST_DB1_CRT $f --output $f"
+        sbsign --key $TEST_DB1_KEY --cert $TEST_DB1_CRT $f --output $f
 done
-
 }
 
 # *********************************************
@@ -388,4 +408,3 @@ then
   CopyDependency Ebc
   CopyDependency PxeBaseCode
 fi
-
diff --git a/uefi-sct/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SecureBoot/BlackBoxTest/Dependency/Keys/GNUmakefile b/uefi-sct/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SecureBoot/BlackBoxTest/Dependency/Keys/GNUmakefile
index 9362579e..8f06495b 100644
--- a/uefi-sct/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SecureBoot/BlackBoxTest/Dependency/Keys/GNUmakefile
+++ b/uefi-sct/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SecureBoot/BlackBoxTest/Dependency/Keys/GNUmakefile
@@ -26,8 +26,26 @@
 
 BASE_NAME=SecureBoot
 TARGET=$(BIN_DIR)/$(BASE_NAME)
+FUTURE_DATE=$(shell date --rfc-3339=date -d "+1 year")
+PAST_DATE=$(shell date --rfc-3339=date -d "-1 year")
 
-all: TestPK1 TestKEK1 TestDB1 TestDBX1
+ifdef KEYS_DIR
+TEST_KEK1_CRT=$(KEYS_DIR)/TestKEK1.crt
+TEST_DB1_CRT=$(KEYS_DIR)/TestDB1.crt
+TEST_DBX1_CRT=$(KEYS_DIR)/TestDBX1.crt
+TEST_PK1_CRT=$(KEYS_DIR)/TestPK1.crt
+TEST_PK1_KEY=$(KEYS_DIR)/TestPK1.key
+else
+TEST_KEYS=TestPK1 TestKEK1 TestDB1 TestDBX1
+TEST_KEK1_CRT=$(BIN_DIR)/SecureBoot_TestKEK1.crt
+TEST_PK1_CRT=$(BIN_DIR)/SecureBoot_TestPK1.crt
+TEST_PK1_KEY=$(BIN_DIR)/SecureBoot_TestPK1.key
+endif
+
+all: $(TEST_KEYS) TestKEK2 KEKSigList1.auth TestImage1.bin NullKEK.auth NullDB.auth NullDBX.auth TestKEK1.auth TestDB1.auth TestDBX1.auth
+
+TestImage1.bin:
+	head -c 16K </dev/urandom > $(TARGET)_$(@)
 
 TestPK1:
 	openssl req -x509 -sha256 -newkey rsa:2048 -subj /CN=ACS_TEST_PK/ -keyout $(TARGET)_$(@).key -out $(TARGET)_$(@).crt -nodes -days 4000
@@ -45,6 +63,39 @@ TestDBX1:
 	openssl req -x509 -sha256 -newkey rsa:2048 -subj /CN=ACS_TEST_DB/ -keyout $(TARGET)_$(@).key -out $(TARGET)_$(@).crt -nodes -days 4000
 	openssl x509 -outform der -in $(TARGET)_$(@).crt -out $(TARGET)_$(@).der
 
+TestKEK2:
+	openssl req -x509 -sha256 -newkey rsa:2048 -subj /CN=ACS_TEST_KEK/ -keyout $(TARGET)_$(@).key -out $(TARGET)_$(@).crt -nodes -days 4000
+
+KEKSigList1.auth: TestKEK2
+	cert-to-efi-sig-list $(TEST_KEK1_CRT) $(BIN_DIR)/SecureBoot_TestKEK1.esl
+	cert-to-efi-sig-list $(BIN_DIR)/SecureBoot_TestKEK2.crt $(BIN_DIR)/SecureBoot_TestKEK2.esl
+	cat $(BIN_DIR)/SecureBoot_TestKEK1.esl $(BIN_DIR)/SecureBoot_TestKEK2.esl > $(BIN_DIR)/SecureBoot_KEKSigList1.esl
+	sign-efi-sig-list -c $(TEST_PK1_CRT) -k $(TEST_PK1_KEY) KEK $(BIN_DIR)/SecureBoot_KEKSigList1.esl $(BIN_DIR)/SecureBoot_KEKSigList1.auth
+
+NullKEK.auth:
+	cat /dev/null > $(BIN_DIR)/SecureBoot_NullKEK.esl
+	sign-efi-sig-list -t $(FUTURE_DATE) -c $(TEST_PK1_CRT) -k $(TEST_PK1_KEY) KEK $(BIN_DIR)/SecureBoot_NullKEK.esl $(BIN_DIR)/SecureBoot_NullKEK.auth
+
+NullDB.auth:
+	cat /dev/null > $(BIN_DIR)/SecureBoot_NullDB.esl
+	sign-efi-sig-list -t $(FUTURE_DATE) -c $(TEST_PK1_CRT) -k $(TEST_PK1_KEY) db $(BIN_DIR)/SecureBoot_NullDB.esl $(BIN_DIR)/SecureBoot_NullDB.auth
+
+NullDBX.auth:
+	cat /dev/null > $(BIN_DIR)/SecureBoot_NullDBX.esl
+	sign-efi-sig-list -t $(FUTURE_DATE) -c $(TEST_PK1_CRT) -k $(TEST_PK1_KEY) dbx $(BIN_DIR)/SecureBoot_NullDBX.esl $(BIN_DIR)/SecureBoot_NullDBX.auth
+
+TestKEK1.auth:
+	cert-to-efi-sig-list $(TEST_KEK1_CRT) $(BIN_DIR)/SecureBoot_TestKEK1.esl
+	sign-efi-sig-list -t $(PAST_DATE) -c $(TEST_PK1_CRT) -k $(TEST_PK1_KEY) KEK $(BIN_DIR)/SecureBoot_TestKEK1.esl $(BIN_DIR)/SecureBoot_TestKEK1.auth
+
+TestDB1.auth:
+	cert-to-efi-sig-list $(TEST_DB1_CRT) $(BIN_DIR)/SecureBoot_TestDB1.esl
+	sign-efi-sig-list -t $(PAST_DATE) -c $(TEST_PK1_CRT) -k $(TEST_PK1_KEY) db $(BIN_DIR)/SecureBoot_TestDB1.esl $(BIN_DIR)/SecureBoot_TestDB1.auth
+
+TestDBX1.auth:
+	cert-to-efi-sig-list $(TEST_DBX1_CRT) $(BIN_DIR)/SecureBoot_TestDBX1.esl
+	sign-efi-sig-list -t $(PAST_DATE) -c $(TEST_PK1_CRT) -k $(TEST_PK1_KEY) dbx $(BIN_DIR)/SecureBoot_TestDBX1.esl $(BIN_DIR)/SecureBoot_TestDBX1.auth
+
 clean:
 	$(RM) $(BIN_DIR)/$(TARGET)_*.key
 	$(RM) $(BIN_DIR)/$(TARGET)_*.crt
diff --git a/uefi-sct/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SecureBoot/BlackBoxTest/Guid.c b/uefi-sct/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SecureBoot/BlackBoxTest/Guid.c
index cefe1828..26a2a7ca 100644
--- a/uefi-sct/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SecureBoot/BlackBoxTest/Guid.c
+++ b/uefi-sct/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SecureBoot/BlackBoxTest/Guid.c
@@ -50,3 +50,5 @@ EFI_GUID gSecureBootVariableAttributesBbTestAssertionGuid006 = EFI_TEST_SECUREBO
 EFI_GUID gSecureBootVariableAttributesBbTestAssertionGuid007 = EFI_TEST_SECUREBOOTVARIABLEATTRIBUTES_ASSERTION_007_GUID;
 
 EFI_GUID gSecureBootVariableAttributesBbTestAssertionGuid008 = EFI_TEST_SECUREBOOTVARIABLEATTRIBUTES_ASSERTION_008_GUID;
+
+EFI_GUID gSecureBootVariableUpdatesBbTestAssertionGuid001 = EFI_TEST_SECUREBOOTVARIABLEUPDATES_ASSERTION_001_GUID;
diff --git a/uefi-sct/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SecureBoot/BlackBoxTest/Guid.h b/uefi-sct/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SecureBoot/BlackBoxTest/Guid.h
index 09f0e972..2a3ff30b 100644
--- a/uefi-sct/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SecureBoot/BlackBoxTest/Guid.h
+++ b/uefi-sct/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SecureBoot/BlackBoxTest/Guid.h
@@ -74,3 +74,8 @@ extern EFI_GUID gSecureBootVariableAttributesBbTestAssertionGuid007;
 { 0xbc37e48e, 0x614f, 0x44e1, {0x9d, 0x9a, 0x80, 0xe5, 0x6c, 0x9b, 0x00, 0x90 }}
 
 extern EFI_GUID gSecureBootVariableAttributesBbTestAssertionGuid008;
+
+#define EFI_TEST_SECUREBOOTVARIABLEUPDATES_ASSERTION_001_GUID \
+{ 0xd2073163, 0xedb0, 0x4d6b, {0xba, 0x8f, 0x5c, 0x61, 0x16, 0xc1, 0x59, 0x2c }}
+
+extern EFI_GUID gSecureBootVariableUpdatesBbTestAssertionGuid001;
diff --git a/uefi-sct/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SecureBoot/BlackBoxTest/SecureBootBBTest.inf b/uefi-sct/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SecureBoot/BlackBoxTest/SecureBootBBTest.inf
index 6e49557d..a93959af 100644
--- a/uefi-sct/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SecureBoot/BlackBoxTest/SecureBootBBTest.inf
+++ b/uefi-sct/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SecureBoot/BlackBoxTest/SecureBootBBTest.inf
@@ -38,6 +38,7 @@
   SecureBootBBTestMain.c
   SecureBootBBTestSupport.c
   VariableAttributesBBTest.c
+  VariableUpdatesBBTest.c
   Guid.h
   Guid.c
 
diff --git a/uefi-sct/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SecureBoot/BlackBoxTest/SecureBootBBTestMain.c b/uefi-sct/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SecureBoot/BlackBoxTest/SecureBootBBTestMain.c
index d96decd1..78df34e6 100644
--- a/uefi-sct/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SecureBoot/BlackBoxTest/SecureBootBBTestMain.c
+++ b/uefi-sct/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SecureBoot/BlackBoxTest/SecureBootBBTestMain.c
@@ -58,6 +58,15 @@ EFI_BB_TEST_ENTRY_FIELD gBBTestEntryField[] = {
     EFI_TEST_CASE_AUTO,
     VariableAttributesTest 
   },
+  {
+    VARIABLE_UPDATES_TEST_GUID,
+    L"VariableUpdates",
+    L"Verifies Secure Boot variable updates.",
+    EFI_TEST_LEVEL_MINIMAL,
+    gSupportProtocolGuid,
+    EFI_TEST_CASE_AUTO,
+    VariableUpdatesTest
+  },
 
   0
 };
diff --git a/uefi-sct/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SecureBoot/BlackBoxTest/SecureBootBBTestMain.h b/uefi-sct/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SecureBoot/BlackBoxTest/SecureBootBBTestMain.h
index 2d1b3b51..d89bbbd5 100644
--- a/uefi-sct/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SecureBoot/BlackBoxTest/SecureBootBBTestMain.h
+++ b/uefi-sct/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SecureBoot/BlackBoxTest/SecureBootBBTestMain.h
@@ -50,6 +50,8 @@ Abstract:
 #define VARIABLE_ATTRIBUTES_TEST_GUID \
   { 0xE39747C4, 0x22D0, 0x4D52, {0x9C, 0x15, 0x3C, 0x4E, 0xFA, 0x80, 0xE6, 0xC8 }}
 
+#define VARIABLE_UPDATES_TEST_GUID \
+  { 0x495CB6D7, 0x0817, 0x4015, {0xA4, 0x79, 0x0D, 0xB4, 0xC2, 0x30, 0x86, 0x26 }}
 
 //
 // Prototypes
@@ -62,6 +64,14 @@ VariableAttributesTest(
   IN EFI_HANDLE                 SupportHandle
   );
 
+EFI_STATUS
+VariableUpdatesTest(
+  IN EFI_BB_TEST_PROTOCOL       *This,
+  IN VOID                       *ClientInterface,
+  IN EFI_TEST_LEVEL             TestLevel,
+  IN EFI_HANDLE                 SupportHandle
+  );
+
 //
 // Support functions
 //
diff --git a/uefi-sct/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SecureBoot/BlackBoxTest/VariableUpdatesBBTest.c b/uefi-sct/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SecureBoot/BlackBoxTest/VariableUpdatesBBTest.c
new file mode 100644
index 00000000..4a3f52a7
--- /dev/null
+++ b/uefi-sct/SctPkg/TestCase/UEFI/EFI/RuntimeServices/SecureBoot/BlackBoxTest/VariableUpdatesBBTest.c
@@ -0,0 +1,728 @@
+/** @file
+
+  Copyright 2006 - 2012 Unified EFI, Inc.<BR>
+  Copyright (c) 2010 - 2018, Intel Corporation. All rights reserved.<BR>
+  Copyright 2021, Arm LTD.
+
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at 
+  http://opensource.org/licenses/bsd-license.php
+ 
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+ 
+**/
+/*++
+
+Module Name:
+  VariableUpdatesTest.c
+
+Abstract:
+  Source file for Secure Boot Variable Updates Black-Box Test - Conformance Test.
+
+--*/
+
+#include "SctLib.h"
+#include "SecureBootBBTestMain.h"
+#include "SecureBootBBTestSupport.h"
+
+#define KEK_ATTRIBUTES (EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | \
+                       EFI_VARIABLE_RUNTIME_ACCESS | EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS)
+#define DB_ATTRIBUTES (EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | \
+                       EFI_VARIABLE_RUNTIME_ACCESS | EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS)
+#define DBX_ATTRIBUTES (EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | \
+                       EFI_VARIABLE_RUNTIME_ACCESS | EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS)
+
+//
+// Prototypes (external)
+//
+
+EFI_STATUS
+VariableUpdatesTest (
+  IN EFI_BB_TEST_PROTOCOL       *This,
+  IN VOID                       *ClientInterface,
+  IN EFI_TEST_LEVEL             TestLevel,
+  IN EFI_HANDLE                 SupportHandle
+  );
+
+
+//
+// Prototypes (internal)
+//
+
+EFI_STATUS
+VariableUpdatesTestCheckpoint1 (
+  IN EFI_RUNTIME_SERVICES                 *RT,
+  IN EFI_STANDARD_TEST_LIBRARY_PROTOCOL   *StandardLib,
+  IN EFI_TEST_LOGGING_LIBRARY_PROTOCOL    *LoggingLib,
+  EFI_TEST_PROFILE_LIBRARY_PROTOCOL   *ProfileLib
+  );
+
+EFI_STATUS
+VariableUpdatesCleanup (
+  IN EFI_RUNTIME_SERVICES                 *RT,
+  IN EFI_STANDARD_TEST_LIBRARY_PROTOCOL   *StandardLib,
+  IN EFI_TEST_LOGGING_LIBRARY_PROTOCOL    *LoggingLib,
+  EFI_TEST_PROFILE_LIBRARY_PROTOCOL   *ProfileLib
+  );
+
+//
+// Functions
+//
+
+/**
+ *  Entry point for Secure Boot Variable Attributes Test.
+ *  @param This             A pointer to the EFI_BB_TEST_PROTOCOL instance.
+ *  @param ClientInterface  A pointer to the interface to be tested.
+ *  @param TestLevel        Test "thoroughness" control.
+ *  @param SupportHandle    A handle containing support protocols.
+ *  @return EFI_SUCCESS     Successfully.
+ *  @return Other value     Something failed.
+ */
+EFI_STATUS
+VariableUpdatesTest(
+  IN EFI_BB_TEST_PROTOCOL       *This,
+  IN VOID                       *ClientInterface,
+  IN EFI_TEST_LEVEL             TestLevel,
+  IN EFI_HANDLE                 SupportHandle
+  )
+{
+  EFI_STATUS                          Status;
+  EFI_RUNTIME_SERVICES                *RT;
+  EFI_STANDARD_TEST_LIBRARY_PROTOCOL  *StandardLib;
+  EFI_TEST_PROFILE_LIBRARY_PROTOCOL   *ProfileLib;
+  EFI_TEST_LOGGING_LIBRARY_PROTOCOL   *LoggingLib;
+
+  //
+  // Get test support library interfaces
+  //
+  Status = GetTestSupportLibrary (
+             SupportHandle,
+             &StandardLib,
+             &ProfileLib,
+             &LoggingLib
+             );
+
+  if (EFI_ERROR(Status)) {
+    return Status;
+  }
+
+  RT = (EFI_RUNTIME_SERVICES *)ClientInterface;
+
+  //
+  // Get the system device path and file path
+  //
+  Status = GetSystemData (ProfileLib);
+  if (EFI_ERROR(Status)) {
+    return Status;
+  }
+
+  Status = VariableUpdatesTestCheckpoint1 (RT, StandardLib, LoggingLib, ProfileLib);
+  if (EFI_ERROR(Status)) {
+    return Status;
+  }
+
+  Status = VariableUpdatesCleanup (RT, StandardLib, LoggingLib, ProfileLib);
+  if (EFI_ERROR(Status)) {
+    return Status;
+  }
+
+  //
+  // Done
+  //
+  return EFI_SUCCESS;
+
+}
+
+/**
+ *  Verify that updates to KEK are signed (by PK)
+ *
+ *  @param StandardLib    A pointer to EFI_STANDARD_TEST_LIBRARY_PROTOCOL
+ *                        instance.
+ *  @param LoggingLib     A pointer to EFI_TEST_LOGGING_LIBRARY_PROTOCOL
+ *                        instance.
+ *  @param ProfileLib     A pointer to EFI_TEST_PROFILE_LIBRARY_PROTOCOL
+ *                        instance.
+ *  @return EFI_SUCCESS   Successfully.
+ *  @return Other value   Something failed.
+ */
+EFI_STATUS
+VariableUpdatesTestCheckpoint1 (
+  IN EFI_RUNTIME_SERVICES                 *RT,
+  IN EFI_STANDARD_TEST_LIBRARY_PROTOCOL   *StandardLib,
+  IN EFI_TEST_LOGGING_LIBRARY_PROTOCOL    *LoggingLib,
+  EFI_TEST_PROFILE_LIBRARY_PROTOCOL   *ProfileLib
+  )
+{
+  EFI_STATUS            Status;
+  EFI_TEST_ASSERTION    Result;
+  UINTN                 DataSize;
+  UINT8                 Data[MAX_BUFFER_SIZE];
+  UINT32                Attributes;
+  EFI_FILE_HANDLE       KeyFHandle;
+  UINT32                KeyFileSize;
+  CHAR16                *FileName;
+  VOID                  *Buffer;
+  UINTN                 BufferSize;
+
+  //
+  // Trace ...
+  //
+  if (LoggingLib != NULL) {
+    LoggingLib->EnterFunction (
+                  LoggingLib,
+                  L"VariableUpdatesTest",
+                  L"UEFI spec, 8.2, 32.3, 32.4.1"
+                  );
+  }
+
+  DataSize = MAX_BUFFER_SIZE;
+  Status = RT->GetVariable (
+                 L"SecureBoot",               // VariableName
+                 &gEfiGlobalVariableGuid,     // VendorGuid
+                 &Attributes,                 // Attributes
+                 &DataSize,                   // DataSize
+                 Data                         // Data
+                 );
+
+  // if SecureBoot is not enabled, exit
+  if (EFI_ERROR(Status) || Data[0] != 1) {
+    StandardLib->RecordMessage (
+                     StandardLib,
+                     EFI_VERBOSE_LEVEL_DEFAULT,
+                     L"VariableAttributesBBTest: SecureBoot not enabled\n"
+                     );
+    return EFI_NOT_FOUND;
+  }
+
+  //
+  // Test KEK update with unsigned data, expect security violation
+  //
+
+  FileName = L"TestImage1.bin";
+  Status = OpenFileAndGetSize (
+             FileName,
+             &KeyFHandle,
+             &KeyFileSize
+             );
+
+  if (EFI_ERROR(Status)) {
+    return EFI_NOT_FOUND;
+  }
+
+  Buffer = SctAllocatePool (KeyFileSize);
+
+  if (Buffer == NULL) {
+    KeyFHandle->Close (KeyFHandle);
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  BufferSize = KeyFileSize;
+
+  Status = KeyFHandle->Read (
+                      KeyFHandle,
+                      &BufferSize,
+                      Buffer
+                      );
+
+  if (EFI_ERROR(Status)) {
+    KeyFHandle->Close (KeyFHandle);
+    gtBS->FreePool (Buffer);
+    return EFI_LOAD_ERROR;
+  }
+
+  Status = RT->SetVariable (
+                     L"KEK",                    // VariableName
+                     &gEfiGlobalVariableGuid,   // VendorGuid
+                     KEK_ATTRIBUTES,            // Attributes
+                     BufferSize,                // DataSize
+                     Buffer                     // Data
+                     );
+
+  if (Status == EFI_SECURITY_VIOLATION) {
+    Result = EFI_TEST_ASSERTION_PASSED;
+  } else {
+    Result = EFI_TEST_ASSERTION_FAILED;
+  }
+
+  StandardLib->RecordAssertion (
+                 StandardLib,
+                 Result,
+                 gSecureBootVariableUpdatesBbTestAssertionGuid001,
+                 L"SecureBoot - Verify unsigned KEK update",
+                 L"%a:%d:Status - %r",
+                 __FILE__,
+                 (UINTN)__LINE__,
+                 Status
+                 );
+
+  gtBS->FreePool (Buffer);
+
+  //
+  // Test KEK update with properly signed data
+  //
+
+  FileName = L"KEKSigList1.auth";
+
+  //
+  //read the key file into memory.
+  //
+  Status = OpenFileAndGetSize (
+             FileName,
+             &KeyFHandle,
+             &KeyFileSize
+             );
+
+  if (EFI_ERROR(Status)) {
+    return EFI_NOT_FOUND;
+  }
+
+  Buffer = SctAllocatePool (KeyFileSize);
+
+  if (Buffer == NULL) {
+    KeyFHandle->Close (KeyFHandle);
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  BufferSize = KeyFileSize;
+
+  Status = KeyFHandle->Read (
+                      KeyFHandle,
+                      &BufferSize,
+                      Buffer
+                      );
+
+  if (EFI_ERROR(Status)) {
+    KeyFHandle->Close (KeyFHandle);
+    gtBS->FreePool (Buffer);
+    return EFI_LOAD_ERROR;
+  }
+
+  Status = RT->SetVariable (
+                     L"KEK",                    // VariableName
+                     &gEfiGlobalVariableGuid,   // VendorGuid
+                     KEK_ATTRIBUTES,            // Attributes
+                     BufferSize,                // DataSize
+                     Buffer                     // Data
+                     );
+
+  if (Status == EFI_SUCCESS) {
+    Result = EFI_TEST_ASSERTION_PASSED;
+  } else {
+    Result = EFI_TEST_ASSERTION_FAILED;
+  }
+
+  StandardLib->RecordAssertion (
+                 StandardLib,
+                 Result,
+                 gSecureBootVariableUpdatesBbTestAssertionGuid001,
+                 L"SecureBoot - Verify signed KEK update",
+                 L"%a:%d:Status - %r",
+                 __FILE__,
+                 (UINTN)__LINE__,
+                 Status
+                 );
+
+  gtBS->FreePool (Buffer);
+
+  //
+  // Trace ...
+  //
+  if (LoggingLib != NULL) {
+    LoggingLib->ExitFunction (
+                  LoggingLib,
+                  L"VariableUpdatesTest",
+                  L"UEFI spec, 8.2, 32.3, 32.4.1"
+                  );
+  }
+
+  //
+  // Done
+  //
+  return EFI_SUCCESS;
+}
+
+/**
+ *  Clean up the secure boot variables
+ *
+ *  @param StandardLib    A pointer to EFI_STANDARD_TEST_LIBRARY_PROTOCOL
+ *                        instance.
+ *  @param LoggingLib     A pointer to EFI_TEST_LOGGING_LIBRARY_PROTOCOL
+ *                        instance.
+ *  @param ProfileLib     A pointer to EFI_TEST_PROFILE_LIBRARY_PROTOCOL
+ *                        instance.
+ *  @return EFI_SUCCESS   Successfully.
+ *  @return Other value   Something failed.
+ */
+EFI_STATUS
+VariableUpdatesCleanup (
+  IN EFI_RUNTIME_SERVICES                 *RT,
+  IN EFI_STANDARD_TEST_LIBRARY_PROTOCOL   *StandardLib,
+  IN EFI_TEST_LOGGING_LIBRARY_PROTOCOL    *LoggingLib,
+  EFI_TEST_PROFILE_LIBRARY_PROTOCOL   *ProfileLib
+  )
+{
+  EFI_STATUS            Status;
+  EFI_TEST_ASSERTION    Result;
+  EFI_FILE_HANDLE       KeyFHandle;
+  UINT32                KeyFileSize;
+  CHAR16                *FileName;
+  VOID                  *Buffer;
+  UINTN                 BufferSize;
+
+  Status = EFI_SUCCESS;
+
+  StandardLib->RecordMessage (
+                     StandardLib,
+                     EFI_VERBOSE_LEVEL_DEFAULT,
+                     L"VariableUpdatesCleanup: Doing cleanup of secure boot variables\n"
+                     );
+  //
+  // Clean up KEK, delete and replace with original value
+  //
+
+  // signed, empty siglist image to delete KEK
+  FileName = L"NullKEK.auth";
+
+  //
+  //read the key file into memory.
+  //
+  Status = OpenFileAndGetSize (
+             FileName,
+             &KeyFHandle,
+             &KeyFileSize
+             );
+
+  if (EFI_ERROR(Status)) {
+    return EFI_NOT_FOUND;
+  }
+
+  Buffer = SctAllocatePool (KeyFileSize);
+
+  if (Buffer == NULL) {
+    KeyFHandle->Close (KeyFHandle);
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  BufferSize = KeyFileSize;
+
+  Status = KeyFHandle->Read (
+                      KeyFHandle,
+                      &BufferSize,
+                      Buffer
+                      );
+
+  if (EFI_ERROR(Status)) {
+    KeyFHandle->Close (KeyFHandle);
+    gtBS->FreePool (Buffer);
+    return EFI_LOAD_ERROR;
+  }
+
+  Status = RT->SetVariable (
+                     L"KEK",                    // VariableName
+                     &gEfiGlobalVariableGuid,   // VendorGuid
+                     KEK_ATTRIBUTES,            // Attributes
+                     BufferSize,                // DataSize
+                     Buffer                     // Data
+                     );
+
+  if (Status != EFI_SUCCESS) {
+    StandardLib->RecordMessage (
+                     StandardLib,
+                     EFI_VERBOSE_LEVEL_DEFAULT,
+                     L"VariableUpdatesCleanup: KEK delete failed\n"
+                     );
+    Status = EFI_NOT_FOUND;
+  }
+
+  gtBS->FreePool (Buffer);
+
+  FileName = L"TestKEK1.auth";
+
+  //
+  //read the key file into memory.
+  //
+  Status = OpenFileAndGetSize (
+             FileName,
+             &KeyFHandle,
+             &KeyFileSize
+             );
+
+  if (EFI_ERROR(Status)) {
+    return EFI_NOT_FOUND;
+  }
+
+  Buffer = SctAllocatePool (KeyFileSize);
+
+  if (Buffer == NULL) {
+    KeyFHandle->Close (KeyFHandle);
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  BufferSize = KeyFileSize;
+
+  Status = KeyFHandle->Read (
+                      KeyFHandle,
+                      &BufferSize,
+                      Buffer
+                      );
+
+  if (EFI_ERROR(Status)) {
+    KeyFHandle->Close (KeyFHandle);
+    gtBS->FreePool (Buffer);
+    return EFI_LOAD_ERROR;
+  }
+
+  Status = RT->SetVariable (
+                     L"KEK",                    // VariableName
+                     &gEfiGlobalVariableGuid,   // VendorGuid
+                     KEK_ATTRIBUTES,            // Attributes
+                     BufferSize,                // DataSize
+                     Buffer                     // Data
+                     );
+
+  if (Status != EFI_SUCCESS) {
+    StandardLib->RecordMessage (
+                     StandardLib,
+                     EFI_VERBOSE_LEVEL_DEFAULT,
+                     L"VariableUpdatesCleanup: KEK clean up failed\n"
+                     );
+    Status = EFI_NOT_FOUND;
+  }
+
+  gtBS->FreePool (Buffer);
+
+  //
+  // Clean up db, delete and replace with original value
+  //
+
+  // signed, empty siglist image to delete db
+  FileName = L"NullDB.auth";
+
+  //
+  //read the key file into memory.
+  //
+  Status = OpenFileAndGetSize (
+             FileName,
+             &KeyFHandle,
+             &KeyFileSize
+             );
+
+  if (EFI_ERROR(Status)) {
+    return EFI_NOT_FOUND;
+  }
+
+  Buffer = SctAllocatePool (KeyFileSize);
+
+  if (Buffer == NULL) {
+    KeyFHandle->Close (KeyFHandle);
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  BufferSize = KeyFileSize;
+
+  Status = KeyFHandle->Read (
+                      KeyFHandle,
+                      &BufferSize,
+                      Buffer
+                      );
+
+  if (EFI_ERROR(Status)) {
+    KeyFHandle->Close (KeyFHandle);
+    gtBS->FreePool (Buffer);
+    return EFI_LOAD_ERROR;
+  }
+
+  Status = RT->SetVariable (
+                     L"db",                    // VariableName
+                     &gEfiImageSecurityDatabaseGuid,   // VendorGuid
+                     DB_ATTRIBUTES,             // Attributes
+                     BufferSize,                // DataSize
+                     Buffer                     // Data
+                     );
+
+  if (Status != EFI_SUCCESS) {
+    StandardLib->RecordMessage (
+                     StandardLib,
+                     EFI_VERBOSE_LEVEL_DEFAULT,
+                     L"VariableUpdatesCleanup: db delete failed\n"
+                     );
+    Status = EFI_NOT_FOUND;
+  }
+
+  gtBS->FreePool (Buffer);
+
+  FileName = L"TestDB1.auth";
+
+  //
+  //read the key file into memory.
+  //
+  Status = OpenFileAndGetSize (
+             FileName,
+             &KeyFHandle,
+             &KeyFileSize
+             );
+
+  if (EFI_ERROR(Status)) {
+    return EFI_NOT_FOUND;
+  }
+
+  Buffer = SctAllocatePool (KeyFileSize);
+
+  if (Buffer == NULL) {
+    KeyFHandle->Close (KeyFHandle);
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  BufferSize = KeyFileSize;
+
+  Status = KeyFHandle->Read (
+                      KeyFHandle,
+                      &BufferSize,
+                      Buffer
+                      );
+
+  if (EFI_ERROR(Status)) {
+    KeyFHandle->Close (KeyFHandle);
+    gtBS->FreePool (Buffer);
+    return EFI_LOAD_ERROR;
+  }
+
+  Status = RT->SetVariable (
+                     L"db",                     // VariableName
+                     &gEfiImageSecurityDatabaseGuid,   // VendorGuid
+                     DB_ATTRIBUTES,             // Attributes
+                     BufferSize,                // DataSize
+                     Buffer                     // Data
+                     );
+
+  if (Status != EFI_SUCCESS) {
+    StandardLib->RecordMessage (
+                     StandardLib,
+                     EFI_VERBOSE_LEVEL_DEFAULT,
+                     L"VariableUpdatesCleanup: db clean up failed\n"
+                     );
+    Status = EFI_NOT_FOUND;
+  }
+
+  gtBS->FreePool (Buffer);
+
+  //
+  // Clean up dbx, delete and replace with original value
+  //
+
+  // signed, empty siglist image to delete dbx
+  FileName = L"NullDBX.auth";
+
+  //
+  //read the key file into memory.
+  //
+  Status = OpenFileAndGetSize (
+             FileName,
+             &KeyFHandle,
+             &KeyFileSize
+             );
+
+  if (EFI_ERROR(Status)) {
+    return EFI_NOT_FOUND;
+  }
+
+  Buffer = SctAllocatePool (KeyFileSize);
+
+  if (Buffer == NULL) {
+    KeyFHandle->Close (KeyFHandle);
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  BufferSize = KeyFileSize;
+
+  Status = KeyFHandle->Read (
+                      KeyFHandle,
+                      &BufferSize,
+                      Buffer
+                      );
+
+  if (EFI_ERROR(Status)) {
+    KeyFHandle->Close (KeyFHandle);
+    gtBS->FreePool (Buffer);
+    return EFI_LOAD_ERROR;
+  }
+
+  Status = RT->SetVariable (
+                     L"dbx",                    // VariableName
+                     &gEfiImageSecurityDatabaseGuid,   // VendorGuid
+                     DBX_ATTRIBUTES,             // Attributes
+                     BufferSize,                // DataSize
+                     Buffer                     // Data
+                     );
+
+  if (Status != EFI_SUCCESS) {
+    StandardLib->RecordMessage (
+                     StandardLib,
+                     EFI_VERBOSE_LEVEL_DEFAULT,
+                     L"VariableUpdatesCleanup: dbx delete failed\n"
+                     );
+    Status = EFI_NOT_FOUND;
+  }
+
+  gtBS->FreePool (Buffer);
+
+  FileName = L"TestDBX1.auth";
+
+  //
+  //read the key file into memory.
+  //
+  Status = OpenFileAndGetSize (
+             FileName,
+             &KeyFHandle,
+             &KeyFileSize
+             );
+
+  if (EFI_ERROR(Status)) {
+    return EFI_NOT_FOUND;
+  }
+
+  Buffer = SctAllocatePool (KeyFileSize);
+
+  if (Buffer == NULL) {
+    KeyFHandle->Close (KeyFHandle);
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  BufferSize = KeyFileSize;
+
+  Status = KeyFHandle->Read (
+                      KeyFHandle,
+                      &BufferSize,
+                      Buffer
+                      );
+
+  if (EFI_ERROR(Status)) {
+    KeyFHandle->Close (KeyFHandle);
+    gtBS->FreePool (Buffer);
+    return EFI_LOAD_ERROR;
+  }
+
+  Status = RT->SetVariable (
+                     L"dbx",                     // VariableName
+                     &gEfiImageSecurityDatabaseGuid,   // VendorGuid
+                     DBX_ATTRIBUTES,             // Attributes
+                     BufferSize,                // DataSize
+                     Buffer                     // Data
+                     );
+
+  if (Status != EFI_SUCCESS) {
+    StandardLib->RecordMessage (
+                     StandardLib,
+                     EFI_VERBOSE_LEVEL_DEFAULT,
+                     L"VariableUpdatesCleanup: dbx clean up failed\n"
+                     );
+    Status = EFI_NOT_FOUND;
+  }
+
+  gtBS->FreePool (Buffer);
+
+  return Status;
+
+}
-- 
2.17.1

